#' Crossvalidation in parallel (same lambda for all components)
#'
#' @param X a number-of-observations times nodes-of-X matrix.
#' @param Y a number-of-observations times nodes-of-Y matrix.
#' @param center logical, indicating if data should be centered.
#' @param argvals_X a set of argument values for X.
#' @param argvals_Y a set of argument values for Y.
#' @param basisobj_X basis object for X.
#' @param basisobj_Y basis object for Y.
#' @param penaltyvec_X a vector of possible penalties for the weights of X.
#' @param penaltyvec_Y a vector of possible penalties for the weights of Y.
#' @param ncomp number of components, integer.
#' @param folds a user defined list of folds (as generated by caret::createFolds())
#' or an integer indicating the number of folds.
#' @param verbose logical, indicating if messages should be printed.
#' @param stripped logical.  If \code{TRUE} the calculations are stripped as
#' much as possible for speed. Particularly, if \code{FALSE} (default) it computes
#' the final models using the best combination of penalties.
#' Inspired by package \code{pls}.
#' @param RPhi matrix of inner products for the basis of X.
#' @param RPsi matrix of inner products for the basis of Y.
#' @param PX penalty matrix for the basis of X.
#' @param PY penalty matrix for the basis of Y.
#' @param ... extra arguments for \code{pls::plsr()} function.
#'
#' @return A list of crossvalidates erros (IMSEs) and penalties giving the minimum
#' IMSEs per number of components.
#' @export
#'
#' @importFrom foreach %dopar%
#' @importFrom foreach %:%
#'
#' @examples
#' # 1D example:
cv_unique_fof_par <- function(X,
                              Y,
                              center = TRUE,
                              argvals_X = NULL,
                              argvals_Y = NULL,
                              basisobj_X,
                              basisobj_Y,
                              penaltyvec_X = 0,
                              penaltyvec_Y = 0,
                              ncomp = min(10, ncol(X)),
                              folds = 5,
                              verbose = TRUE,
                              stripped = TRUE,
                              RPhi = NULL,
                              RPsi = NULL,
                              PX = NULL,
                              PY = NULL,
                              ...) {


  # Initialize grid for the first component
  penalty_grid <- expand.grid(penalty_X = penaltyvec_X,
                              penalty_Y = penaltyvec_Y)

  if (is.numeric(folds)) {

    num_folds <- folds
    folds <- caret::createFolds(1:nrow(Y), k = num_folds)

  }else if (is.list(folds)) {

    num_folds <- length(folds)

  }

  # Initialize CVEs:
  CVEs_ncomp <- array(data = NA, dim = ncomp) # averaged
  names(CVEs_ncomp) <- paste0("ncomp_", 1:ncomp)

  # Initialize computation times:
  cve_times_ncomp <- array(data = NA, dim = ncomp)
  names(cve_times_ncomp) <- paste0("ncomp_", 1:ncomp)

  # Initialize MSEs per fold:
  MSE_ncomp_fold <- matrix(data = NA,
                           nrow = ncomp,
                           ncol = num_folds) # MSE per component per fold
  colnames(MSE_ncomp_fold) <- paste0("fold_", 1:num_folds)
  rownames(MSE_ncomp_fold) <- paste0("ncomp_", 1:ncomp)

  # Best penalties (unique) for each ncomp_i:
  best_penalties <- matrix(data = NA,
                           nrow = ncomp,
                           ncol = 2)
  rownames(best_penalties) <- paste0("ncomp_", 1:ncomp)
  colnames(best_penalties) <- colnames(penalty_grid)


  for (ncomp_i in 1:ncomp) {


    tictoc::tic(paste0("Crossvalidation component # ", ncomp_i))

    if (verbose) {
      cat("Component ", ncomp_i, "/", ncomp, "\n")
    }


    i <- row_lambda <- NULL
    MSE_lambda_fold <- foreach::foreach (i = 1:num_folds,
                                         .packages = c("penFoFPLS"),
                                         .combine = "cbind") %:%
      foreach::foreach(row_lambda = 1:nrow(penalty_grid),
                       .packages = c("penFoFPLS"),
                       .combine = 'c' ) %dopar%
      {

        # MSE_lambda_fold <- matrix(NA, nrow = nrow(penalty_grid), ncol = num_folds)
        # for (i in 1:num_folds) {
        #   for (row_lambda in 1:nrow(penalty_grid)) {

        # build train
        Y_fold_train <- Y[-folds[[i]], , drop = F]
        X_fold_train <- X[-folds[[i]], , drop = F]

        # build test:
        Y_fold_test <- Y[folds[[i]], , drop = F]
        X_fold_test <- X[folds[[i]], , drop = F]


        res_fpls <- ffpls_bs(X = X_fold_train,
                             Y = Y_fold_train,
                             argvals_X = argvals_X,
                             argvals_Y = argvals_Y,
                             ncomp = ncomp_i,
                             center = center,
                             basisobj_X = basisobj_X,
                             basisobj_Y = basisobj_Y,
                             penalty_X = penalty_grid[row_lambda, "penalty_X"],
                             penalty_Y = penalty_grid[row_lambda, "penalty_Y"],
                             verbose = FALSE,
                             stripped = stripped,
                             RPhi = RPhi,
                             RPsi = RPsi,
                             PX = PX,
                             PY = PY,
                             ...      )


        # MSE_lambda_fold[row_lambda , i] <-
        num_int_1d(argvals = argvals_Y,
                   f_obs = colMeans( (Y_fold_test -
                                        stats::predict(object = res_fpls,
                                                       newdata = X_fold_test)[, , ncomp_i]  )^2 ) )



        #   } # loop row_lambda
        # } # loop fold

      } # nested loop parallel


    # Averaged MSE_fold:
    CVEs_ncomp_lambda <- rowMeans(MSE_lambda_fold)

    # Best penalties per component:
    sel_lambda <- which.min(CVEs_ncomp_lambda)
    best_penalties[ncomp_i, ] <- as.numeric(penalty_grid[sel_lambda, ])

    # Save the folds-averaged CV error:
    CVEs_ncomp[ncomp_i] <- CVEs_ncomp_lambda[sel_lambda]

    # Save MSEs per fold, for the best lambda:
    MSE_ncomp_fold[ncomp_i, ] <- MSE_lambda_fold[sel_lambda, ]

    # Save times
    elapsed_time <- tictoc::toc(quiet = !verbose)
    cve_times_ncomp[[paste0("ncomp_", ncomp_i)]] <- elapsed_time[["toc"]][["elapsed"]] - elapsed_time[["tic"]][["elapsed"]]

  } # loop in ncomp: number of components

  # Transform into accumulated times:
  cve_times_ncomp <- cumsum(cve_times_ncomp)

  # fix names:

  if (stripped) {
    ret <- list(
      CVEs_ncomp = CVEs_ncomp,
      MSE_ncomp_fold = MSE_ncomp_fold,
      best_penalties = best_penalties,
      elapsed = cve_times_ncomp
    )
  }else {

    if (verbose) {
      cat("Fitting final model\n")
    }

    final_model <- ffpls_bs(X = X,
                            Y = Y,
                            argvals_X = argvals_X,
                            argvals_Y = argvals_Y,
                            ncomp = ncomp,
                            center = center,
                            basisobj_X = basisobj_X,
                            basisobj_Y = basisobj_Y,
                            penalty_X = best_penalties[ncomp, "penalty_X"],
                            penalty_Y = best_penalties[ncomp, "penalty_Y"],
                            verbose = FALSE,
                            stripped = stripped,
                            RPhi = RPhi,
                            RPsi = RPsi,
                            PX = PX,
                            PY = PY,
                            ...)

    ret <- list(
      CVEs_ncomp = CVEs_ncomp,
      MSE_ncomp_fold = MSE_ncomp_fold,
      best_penalties = best_penalties,
      final_model = final_model,
      elapsed = cve_times_ncomp
    )

  }

  class(ret) <- "cv_fofr"

  return(ret)
}
